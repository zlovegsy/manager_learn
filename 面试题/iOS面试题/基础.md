	
###属性readwrite.readonly,assign,retain,copy,nonatomic 什么作用 ? 在哪种情况下 ?
 
1. readwrite 是可读可写特性；
1. 需要生成getter方法和setter方法时（补充：默认属性，将生成不带额外参数的getter和setter方法（setter方法只有一个参数））
1. readonly 是只读特性 只会生成getter方法 不会生成setter方法 ;不希望属性在类外改变
1. assign 是赋值特性，setter方法将传入参数赋值给实例变量；仅设置变量时，用于修饰非对象类型；
1. weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而 assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作

1. retain 表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1;
1. copy 表示拷贝特性，setter方法将传入对象复制一份；需要完全一份新的变量时。
1. nonatomic 非原子操作，决定编译器生成的setter getter是否是原子操作，atomic表示多线程安全，一般使 用nonatomic（它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁）

### IBOutlet 连出来的视图属性为什么可以被设置成weak?

在 storyboard 中添加一个控件引用关系是这样的(以 UIbutton 为例): UIviewController -> UIview -> UIbutton此时 UIviewController 强引用着 UIview , UIview 强引用着 UIbutton , IBoutlet 连线到控制器的. m 或者. h 中作为视图的属性时用 weak 修饰就可以了, (觉得用 strong 修饰也可以但是没有必要)

添加到子控件也是强引用: UIbutton 就是添加到了 UIviewController 的 view 上

### 1.import 和 include 区别
相同点：include和import的作用都是用来包含头文件：结构体，符号常量，函数原型等元素的声明。
不同点：import保证头文件只会被包含一次，而在c语言中使用#ifdef来实现

	#ifndef A_H_  
	#define A_H_  
		void fun();  
	#endif  
	
### 2.谈一谈OC的内存管理
[iOS内存管理](https://imaginelove.gitee.io/blog/2018/03/30/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/)

**有对象的地方就有内存管理，因为对象都是存放在堆区的，需要自己释放**

**OC的内存管理方式有两种，MRR manual retain-release/ MRC manual reference counting（iOS5之前）和ARC automatic reference counting：**

1. MRC／MRR是自己“手动保留释放”，跟踪拥有的对象来显式管理内存。通过引用计数的模型实现。

2. 在自动引用计数或ARC中，系统使用与MRC相同的引用计数系统，但它会在编译时插入适当的内存管理方法调用。如果使用ARC，通常不需要理解本文档中描述的底层实现。

**良好的做法可以防止与内存相关的问题，内存管理不正确会导致两种主要问题：**

1. 释放或覆盖仍在使用的数据，这会导致内存损坏，并且通常会导致应用程序崩溃，甚至导致用户数据损坏。

2. 不释放不再使用的数据会导致内存泄漏，内存泄漏是分配的内存不被释放的地方，即使它不再被使用。泄漏导致您的应用程序使用不断增加的内存量，这反过来可能导致系统性能下降或应用程序终止。

从引用计数的角度考虑内存管理通常会适得其反，往往会根据实现细节而不是实际目标来考虑内存管理。相反，应该从对象所有权和对象图的角度考虑内存管理。

### 3.谈一谈Tableviewcell的重用机制
tableView的重用最主要的目的是为了节省内存资源，把View和data分离开来，当需要n多个cell的时候，只需要创建多余屏幕当前可见的cell就可以了，但重用也会带来一些不好的事情，比如会导致数据混乱等等

1. prepareForReuse会在cell返回前最先调用，用来解决数据混乱




### 4.多线程
**锁 是什么？**

我们在使用多线程的时候多个线程可能会访问同一块资源，这样就很容易引发数据错乱和数据安全等问题，这时候就需要我们保证每次只有一个线程访问这一块资源，锁 应运而生。

自旋锁
互斥锁

何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。

**什么是多线程？**

多线程：是指从软件或者硬件上实现多个线程的并发技术。

**多线程的好处**：

1. 使用多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载
2. 发挥多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好

**多线程的缺点**：

1. 大量的线程降低代码的可读性；
2. 更多的线程需要更多的内存空间
3. 当多个线程对同一个资源出现争夺时候要注意线程安全的问题。




### 5.runtime
[让你快速上手Runtime](https://www.jianshu.com/p/e071206103a4)
[iOS~runtime理解](https://www.jianshu.com/p/927c8384855a)

RunTime简称运行时。OC就是运行时机制，也就是在运行时候的一些机制，其中最主要的是消息机制。
对于C语言，函数的调用在编译的时候会决定调用哪个函数。
对于OC的函数，属于动态调用过程，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用。
事实证明：
在编译阶段，OC可以调用任何函数，即使这个函数并未实现，只要声明过就不会报错。
在编译阶段，C语言调用未实现的函数就会报错。



### 6.runloop
[深入理解RunLoop](https://blog.ibireme.com/2015/05/18/runloop/)

[runloop官方文档](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html)


### 7.tcp/ip Http
[tcp/udp](https://juejin.im/post/5b189ca0f265da6e1e1adcbf)

[tcp/http](https://www.jianshu.com/p/947a2673102a)

一、概念：

key:TCP是一种面向连接的、可靠的、字节流服务

   

1.面向链接：TCP面向链接，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须通过三次握手先建立一个TCP连接。在一个TCP中仅有两方彼此通信，多播和广播不能用于TCP。UDP是不可靠的传输，传输前不需要建立链接，可以应用多播和广播实现一对多的通信。

 
2.可靠性：TCP提供端到端的流量控制，对收到的数据进行确认，采用超时重发，对失序的数据进行重新排序等机制保证数据通信的可靠性。而UDP是一种不可靠的服务，接收方可能不能收到发送方的数据报。

 
3.TCP是一种流模式的协议，UDP是一种数据报模式的协议。进程的每个输出操作都正好产生一个UDP数据报，并组装成一份待发送的IP数据报。TCP应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系。TCP会有粘包和半包的现象。

 
4.效率上：速度上，一般TCP速度慢，传输过程中需要对数据进行确认，超时重发，还要对数据进行排序。UDP没有这些机制所以速度快。数据比例，TCP头至少20个字节，UDP头8个字节，相对效率高。组装效率上：TCP头至少20个字节，UDP头8个字节，系统组装上TCP相对慢。

 
5.用途上：用于TCP可靠性，http，ftp使用。而由于UDP速度快，视频，在线游戏多用UDP，保证实时性

 
对于第三点的理解。TCP可能发送100个“包”，而接收到50个“包”，不是丢“包”了，而是每次接受的“包”都比发送的多，其实TCP并没有包的概念。例如，每次发10个字节，可能读得时候一次读了20个字节。TCP是一种流模式的协议，在接收到的缓存中按照发送的包得顺序自动按照顺序拼接好，因为数据基本来自同一个主机，而且是按照顺序发送过来的，TCP的缓存中存放的就是，连续的数据。感觉好像是多封装了一步比UDP。而UDP因为可能两个不同的主机，给同一个主机发送，（一个端口可能收到多个应用程序的数据），或者按照TCP那样合并数据，必然会造成数据错误。我觉得关键的原因还是，TCP是面向连接，而UDP是无连接的，这就导致，TCP接收的数据为一个主机发来且有序无误的，而UDP可能是多个主机发来的无序，可能错误的

### 8.面向对象
#### (1)面向对象技术的基本概念
1. 面向对象技术是 20 世纪 80 年代初提出并很快流行起来的。该技术是基于“抽象”和 “隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、 服从相同规则的一系列事物(事物可以是一个物理实体、一个概念或一个软件模块等)的抽 象，而把其中的具体事物称为对象的实例。如果在 OS 中的各类实体如进程、线程、消息、 存储器和文件等，都使用了对象这一概念，相应地，便有了进程对象、线程对象、存储器 对象和文件对象等。

2. 在面向对象的技术中，是利用被封装的数据结构(变量)和一组对它进行操作的过程(方 法)，来表示系统中的某个对象的，如图 1-7 所示。对象中的变量(数据)也称为属性，它可以 是单个标量或一张表。面向对象中的方法是用于执行某种功能的过程，它可以改变对象的状态，更新对象中的某些数据值或作用于对象所要访问的外部 资源。对象中的变量(数据)对外是隐蔽的，因而外界不能对它直 接进行访问，必须通过该对象中的一组方法(操作函数)对它进 行访问。例如要想对上面的文件 A 执行打开操作，必须用该对象中的打开过程去打开它。 同样对象中的一组方法的实现细节也是隐蔽的，因此，对象中的变量可以得到很好的保护， 而不会允许未经受权者使用和不正确的操作。

#### (2)面向对象技术的优点
 在设计操作系统时，将计算机中的实体作为对象来处理，可带来如下好处:
 
1. 通过“重用”提高产品质量和生产率。
在面向对象技术中可通过“重用”以前项目中经过精心测试的对象，或由其他人编写、 测试和维护的对象类，来构建新的系统，这不仅可大大降低开发成本，而且能获得更好的 系统质量。

2. 使系统具有更好的易修改性和易扩展性。
通过封装，可隐蔽对象中的变量和方法，因而当改变对象中的变量和方法时，不会影 响到其它部分，从而可方便地修改老的对象类。另外，继承是面向对象技术的重要特性， 在创建一个新对象类时，通过利用继承特性，可显著地减少开发的时空开销，使系统具有 更好的易扩展性和灵活性。

3. 更易于保证系统的“正确性”和“可靠性”。
对象是构成操作系统的基本单元，由于可以独立地对它进行测试，易于保证每个对象 的正确性和可靠性，因此也就比较容易保证整个系统的正确性和可靠性。此外，封装对对 象类中的信息进行了隐蔽，这样又可有效地防止未经授权者的访问和用户不正确的使用， 有助于构建更为安全的系统。









 